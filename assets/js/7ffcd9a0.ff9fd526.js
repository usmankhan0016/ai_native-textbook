"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[7975],{8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function a(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(o.Provider,{value:e},n.children)}},8495:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1/chapter-4-urdf-for-humanoids","title":"Chapter 4: URDF for Humanoid Robots","description":"Learning Objectives","source":"@site/docs/module-1/chapter-4-urdf-for-humanoids.md","sourceDirName":"module-1","slug":"/module-1/chapter-4-urdf-for-humanoids","permalink":"/ai_native-textbook/docs/module-1/chapter-4-urdf-for-humanoids","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"URDF","permalink":"/ai_native-textbook/docs/tags/urdf"},{"inline":true,"label":"Xacro","permalink":"/ai_native-textbook/docs/tags/xacro"},{"inline":true,"label":"RViz","permalink":"/ai_native-textbook/docs/tags/r-viz"},{"inline":true,"label":"Gazebo","permalink":"/ai_native-textbook/docs/tags/gazebo"},{"inline":true,"label":"Humanoid","permalink":"/ai_native-textbook/docs/tags/humanoid"},{"inline":true,"label":"Week5","permalink":"/ai_native-textbook/docs/tags/week-5"}],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Chapter 4: URDF for Humanoid Robots","tags":["URDF","Xacro","RViz","Gazebo","Humanoid","Week5"],"difficulty":"Beginner","module":1,"week":5,"prerequisites":["Chapter 1","Chapter 2","Chapter 3","XML basics"],"estimated_time":"6-8 hours","topics":["URDF","Xacro","RViz visualization","Gazebo simulation","Robot kinematics","Collision meshes"]},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Packages, Launch Files, and Parameters","permalink":"/ai_native-textbook/docs/module-1/chapter-3-ros2-packages-launch"},"next":{"title":"Week 3 Practice Guide","permalink":"/ai_native-textbook/docs/module-1/week-3"}}');var s=i(4848),o=i(8453);const a={sidebar_position:5,title:"Chapter 4: URDF for Humanoid Robots",tags:["URDF","Xacro","RViz","Gazebo","Humanoid","Week5"],difficulty:"Beginner",module:1,week:5,prerequisites:["Chapter 1","Chapter 2","Chapter 3","XML basics"],estimated_time:"6-8 hours",topics:["URDF","Xacro","RViz visualization","Gazebo simulation","Robot kinematics","Collision meshes"]},l="Chapter 4: URDF for Humanoid Robots",t={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"4.1 URDF Fundamentals",id:"41-urdf-fundamentals",level:2},{value:"Basic URDF Structure",id:"basic-urdf-structure",level:3},{value:"Joint Types",id:"joint-types",level:3},{value:"4.2 Humanoid URDF Example",id:"42-humanoid-urdf-example",level:2},{value:"Humanoid Kinematic Chain",id:"humanoid-kinematic-chain",level:3},{value:"Complete Humanoid Upper Body URDF",id:"complete-humanoid-upper-body-urdf",level:3},{value:"4.3 Xacro: Reducing Code Duplication",id:"43-xacro-reducing-code-duplication",level:2},{value:"Xacro Basics",id:"xacro-basics",level:3},{value:"Converting Xacro to URDF",id:"converting-xacro-to-urdf",level:3},{value:"4.4 Visualizing in RViz",id:"44-visualizing-in-rviz",level:2},{value:"Step 1: Create Launch File for Visualization",id:"step-1-create-launch-file-for-visualization",level:3},{value:"Step 2: Create RViz Config File",id:"step-2-create-rviz-config-file",level:3},{value:"Step 3: Launch RViz",id:"step-3-launch-rviz",level:3},{value:"4.5 Gazebo Physics Simulation",id:"45-gazebo-physics-simulation",level:2},{value:"Adding Gazebo Properties",id:"adding-gazebo-properties",level:3},{value:"Launch Gazebo with Robot",id:"launch-gazebo-with-robot",level:3},{value:"4.6 Collision vs Visual Meshes",id:"46-collision-vs-visual-meshes",level:2},{value:"Example: Hand with Separate Meshes",id:"example-hand-with-separate-meshes",level:3},{value:"4.7 URDF Best Practices for Humanoids",id:"47-urdf-best-practices-for-humanoids",level:2},{value:"1. Coordinate Frame Conventions",id:"1-coordinate-frame-conventions",level:3},{value:"2. Joint Limits",id:"2-joint-limits",level:3},{value:"3. Mass and Inertia",id:"3-mass-and-inertia",level:3},{value:"4. Modular Design with Xacro",id:"4-modular-design-with-xacro",level:3},{value:"5. Version Control URDF",id:"5-version-control-urdf",level:3},{value:"End-of-Chapter Exercises",id:"end-of-chapter-exercises",level:2},{value:"Exercise 1: Simple Mobile Robot (Easy)",id:"exercise-1-simple-mobile-robot-easy",level:3},{value:"Exercise 2: Xacro Parameterization (Easy-Medium)",id:"exercise-2-xacro-parameterization-easy-medium",level:3},{value:"Exercise 3: Add Sensors to Humanoid (Medium)",id:"exercise-3-add-sensors-to-humanoid-medium",level:3},{value:"Exercise 4: Humanoid Legs (Medium-Hard)",id:"exercise-4-humanoid-legs-medium-hard",level:3},{value:"Exercise 5: Collision Geometry Optimization (Medium-Hard)",id:"exercise-5-collision-geometry-optimization-medium-hard",level:3},{value:"Exercise 6: Complete Humanoid Robot (Hard)",id:"exercise-6-complete-humanoid-robot-hard",level:3},{value:"Capstone Integration: Module 1 Final Project",id:"capstone-integration-module-1-final-project",level:2},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"What&#39;s Next?",id:"whats-next",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-4-urdf-for-humanoid-robots",children:"Chapter 4: URDF for Humanoid Robots"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Write URDF files"})," to describe robot structure with links, joints, and physical properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Create humanoid robot models"})," with torso, head, arms, legs, and hands"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Xacro"})," to reduce code duplication and create parameterized robot models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visualize robots in RViz"})," using joint state publishers and robot state publishers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Load URDF into Gazebo"})," with physics properties, sensors, and controller plugins"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Optimize URDF"})," with separate collision and visual meshes for performance"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(e.p,{children:"This chapter introduces six critical concepts for robot modeling:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"}),": XML-based format for describing robot kinematics, dynamics, and visualization"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Link"}),": A rigid body in the robot (e.g., torso, upper arm, forearm)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint"}),": Connection between two links defining how they move relative to each other"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Xacro (XML Macros)"}),": Macro language for URDF that enables variables, functions, and code reuse"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"RViz"}),": 3D visualization tool for viewing robot models and sensor data"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo URDF Extensions"}),": Tags for physics simulation, sensors, and controller plugins"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"41-urdf-fundamentals",children:"4.1 URDF Fundamentals"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})," is an XML specification for representing a robot's physical structure. It defines:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Links"}),": Rigid bodies with visual appearance, collision geometry, and inertial properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joints"}),": Connections between links with motion constraints"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"basic-urdf-structure",children:"Basic URDF Structure"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: Simple robot with two links and one joint --\x3e\n\n<?xml version="1.0"?>\n<robot name="simple_robot">\n\n  \x3c!-- Base link (fixed to world) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Moving link (arm) --\x3e\n  <link name="arm_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.5"/>\n      </geometry>\n      <material name="red">\n        <color rgba="0.8 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Revolute joint (rotation) --\x3e\n  <joint name="base_to_arm" type="revolute">\n    <parent link="base_link"/>\n    <child link="arm_link"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Elements"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<link>"}),": Defines a rigid body","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<visual>"}),": How the link appears in visualization (RViz)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<collision>"}),": Simplified geometry for collision detection"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<inertial>"}),": Mass and inertia tensor for physics simulation"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<joint>"}),": Connects parent and child links","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<origin>"}),": Translation (xyz) and rotation (roll-pitch-yaw) from parent to joint"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<axis>"}),": Rotation axis for revolute/continuous joints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<limit>"}),": Joint constraints (position, velocity, effort)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"joint-types",children:"Joint Types"}),"\n",(0,s.jsx)(e.p,{children:"URDF supports six joint types:"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Joint Type"}),(0,s.jsx)(e.th,{children:"Description"}),(0,s.jsx)(e.th,{children:"Use Case"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"fixed"})}),(0,s.jsx)(e.td,{children:"No motion (welded connection)"}),(0,s.jsx)(e.td,{children:"Attach sensors, connect rigid parts"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"revolute"})}),(0,s.jsx)(e.td,{children:"Rotation with limits"}),(0,s.jsx)(e.td,{children:"Humanoid joints (elbows, knees, neck)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"continuous"})}),(0,s.jsx)(e.td,{children:"Unlimited rotation"}),(0,s.jsx)(e.td,{children:"Wheels, rotating sensors"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"prismatic"})}),(0,s.jsx)(e.td,{children:"Linear translation with limits"}),(0,s.jsx)(e.td,{children:"Telescoping links, grippers"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"planar"})}),(0,s.jsx)(e.td,{children:"Motion in a plane (2D translation + 1D rotation)"}),(0,s.jsx)(e.td,{children:"Rarely used in humanoids"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"floating"})}),(0,s.jsx)(e.td,{children:"6-DOF free motion (no constraints)"}),(0,s.jsx)(e.td,{children:"Simulating free-flying robots"})]})]})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"For humanoids"}),", you'll primarily use:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"revolute"})," for all limb joints (shoulders, elbows, hips, knees, ankles, fingers)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fixed"})," for attaching cameras, IMUs, and other sensors"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"42-humanoid-urdf-example",children:"4.2 Humanoid URDF Example"}),"\n",(0,s.jsx)(e.p,{children:"Let's build a simplified humanoid upper body with head, torso, and arms."}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-kinematic-chain",children:"Humanoid Kinematic Chain"}),"\n",(0,s.jsx)(e.mermaid,{value:"graph TD\n    Base[base_link<br/>Fixed to world] --\x3e Torso[torso]\n    Torso --\x3e Head[head]\n    Torso --\x3e LShoulder[left_shoulder]\n    Torso --\x3e RShoulder[right_shoulder]\n    LShoulder --\x3e LUpperArm[left_upper_arm]\n    LUpperArm --\x3e LForearm[left_forearm]\n    LForearm --\x3e LHand[left_hand]\n    RShoulder --\x3e RUpperArm[right_upper_arm]\n    RUpperArm --\x3e RForearm[right_forearm]\n    RForearm --\x3e RHand[right_hand]\n\n    style Base fill:#e1f5ff\n    style Torso fill:#fff4e1\n    style Head fill:#ffe1e1\n    style LShoulder fill:#e1ffe1\n    style RShoulder fill:#e1ffe1"}),"\n",(0,s.jsx)(e.h3,{id:"complete-humanoid-upper-body-urdf",children:"Complete Humanoid Upper Body URDF"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: ~/ros2_ws/src/humanoid_description/urdf/humanoid_upper_body.urdf --\x3e\n\n<?xml version="1.0"?>\n<robot name="humanoid_upper_body">\n\n  \x3c!-- ========== BASE LINK (Fixed to world) ========== --\x3e\n  <link name="base_link"/>\n\n  \x3c!-- ========== TORSO ========== --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="white">\n        <color rgba="0.9 0.9 0.9 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="15.0"/>\n      <origin xyz="0 0 0.25"/>\n      <inertia ixx="0.5" ixy="0" ixz="0" iyy="0.5" iyz="0" izz="0.2"/>\n    </inertial>\n  </link>\n\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- ========== HEAD ========== --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.96 0.8 0.69 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="3.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- ========== LEFT ARM ========== --\x3e\n  \x3c!-- Shoulder joint --\x3e\n  <link name="left_shoulder">\n    <visual>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_shoulder"/>\n    <origin xyz="0 0.15 0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Upper arm --\x3e\n  <link name="left_upper_arm">\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.96 0.8 0.69 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 -0.15"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_shoulder_to_upper_arm" type="fixed">\n    <parent link="left_shoulder"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Elbow joint --\x3e\n  <link name="left_forearm">\n    <visual>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.96 0.8 0.69 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.125"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_elbow_joint" type="revolute">\n    <parent link="left_upper_arm"/>\n    <child link="left_forearm"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="2.5" effort="80" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Hand --\x3e\n  <link name="left_hand">\n    <visual>\n      <geometry>\n        <box size="0.08 0.15 0.05"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.96 0.8 0.69 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.08 0.15 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_wrist_joint" type="fixed">\n    <parent link="left_forearm"/>\n    <child link="left_hand"/>\n    <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- ========== RIGHT ARM (Mirror of left) ========== --\x3e\n  \x3c!-- Shoulder joint --\x3e\n  <link name="right_shoulder">\n    <visual>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n      <material name="dark_gray"/>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Note: Y offset is negative for right side --\x3e\n  <joint name="right_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="right_shoulder"/>\n    <origin xyz="0 -0.15 0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Upper arm --\x3e\n  <link name="right_upper_arm">\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="skin"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 -0.15"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="right_shoulder_to_upper_arm" type="fixed">\n    <parent link="right_shoulder"/>\n    <child link="right_upper_arm"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Forearm --\x3e\n  <link name="right_forearm">\n    <visual>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n      <material name="skin"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.125"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="right_elbow_joint" type="revolute">\n    <parent link="right_upper_arm"/>\n    <child link="right_forearm"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="2.5" effort="80" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Hand --\x3e\n  <link name="right_hand">\n    <visual>\n      <geometry>\n        <box size="0.08 0.15 0.05"/>\n      </geometry>\n      <material name="skin"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.08 0.15 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="right_wrist_joint" type="fixed">\n    <parent link="right_forearm"/>\n    <child link="right_hand"/>\n    <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Design Decisions"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Coordinate Frames"}),": Z-axis points up (ROS convention)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Symmetry"}),": Right arm mirrors left arm (negative Y offset)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint Limits"}),": Realistic ranges (e.g., elbow: 0 to 2.5 rad \u2248 0\xb0 to 143\xb0)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertial Properties"}),": Masses and inertias approximate real human proportions"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"43-xacro-reducing-code-duplication",children:"4.3 Xacro: Reducing Code Duplication"}),"\n",(0,s.jsxs)(e.p,{children:["The URDF above has significant duplication (left and right arms are nearly identical). ",(0,s.jsx)(e.strong,{children:"Xacro"})," eliminates this with macros."]}),"\n",(0,s.jsx)(e.h3,{id:"xacro-basics",children:"Xacro Basics"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: ~/ros2_ws/src/humanoid_description/urdf/humanoid_upper_body.urdf.xacro --\x3e\n\n<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_upper_body">\n\n  \x3c!-- ========== PROPERTIES (Constants) ========== --\x3e\n  <xacro:property name="torso_mass" value="15.0"/>\n  <xacro:property name="head_mass" value="3.0"/>\n  <xacro:property name="upper_arm_length" value="0.3"/>\n  <xacro:property name="forearm_length" value="0.25"/>\n  <xacro:property name="arm_mass" value="2.0"/>\n\n  \x3c!-- ========== MACROS ========== --\x3e\n  \x3c!-- Macro for creating an arm (left or right) --\x3e\n  <xacro:macro name="humanoid_arm" params="side reflect">\n    \x3c!-- side: \'left\' or \'right\' --\x3e\n    \x3c!-- reflect: 1 for left, -1 for right (mirrors Y offset) --\x3e\n\n    \x3c!-- Shoulder joint --\x3e\n    <link name="${side}_shoulder">\n      <visual>\n        <geometry>\n          <sphere radius="0.05"/>\n        </geometry>\n        <material name="dark_gray">\n          <color rgba="0.3 0.3 0.3 1"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <sphere radius="0.05"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="0.5"/>\n        <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n      </inertial>\n    </link>\n\n    <joint name="${side}_shoulder_joint" type="revolute">\n      <parent link="torso"/>\n      <child link="${side}_shoulder"/>\n      <origin xyz="0 ${reflect * 0.15} 0.2" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-3.14" upper="3.14" effort="100" velocity="2.0"/>\n    </joint>\n\n    \x3c!-- Upper arm --\x3e\n    <link name="${side}_upper_arm">\n      <visual>\n        <origin xyz="0 0 ${-upper_arm_length/2}" rpy="0 0 0"/>\n        <geometry>\n          <cylinder radius="0.04" length="${upper_arm_length}"/>\n        </geometry>\n        <material name="skin">\n          <color rgba="0.96 0.8 0.69 1"/>\n        </material>\n      </visual>\n      <collision>\n        <origin xyz="0 0 ${-upper_arm_length/2}" rpy="0 0 0"/>\n        <geometry>\n          <cylinder radius="0.04" length="${upper_arm_length}"/>\n        </geometry>\n      </collision>\n      <xacro:cylinder_inertia mass="${arm_mass}" radius="0.04" length="${upper_arm_length}"/>\n    </link>\n\n    <joint name="${side}_shoulder_to_upper_arm" type="fixed">\n      <parent link="${side}_shoulder"/>\n      <child link="${side}_upper_arm"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n    </joint>\n\n    \x3c!-- Forearm --\x3e\n    <link name="${side}_forearm">\n      <visual>\n        <origin xyz="0 0 ${-forearm_length/2}" rpy="0 0 0"/>\n        <geometry>\n          <cylinder radius="0.035" length="${forearm_length}"/>\n        </geometry>\n        <material name="skin"/>\n      </visual>\n      <collision>\n        <origin xyz="0 0 ${-forearm_length/2}" rpy="0 0 0"/>\n        <geometry>\n          <cylinder radius="0.035" length="${forearm_length}"/>\n        </geometry>\n      </collision>\n      <xacro:cylinder_inertia mass="1.5" radius="0.035" length="${forearm_length}"/>\n    </link>\n\n    <joint name="${side}_elbow_joint" type="revolute">\n      <parent link="${side}_upper_arm"/>\n      <child link="${side}_forearm"/>\n      <origin xyz="0 0 ${-upper_arm_length}" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="0" upper="2.5" effort="80" velocity="2.0"/>\n    </joint>\n\n    \x3c!-- Hand --\x3e\n    <link name="${side}_hand">\n      <visual>\n        <geometry>\n          <box size="0.08 0.15 0.05"/>\n        </geometry>\n        <material name="skin"/>\n      </visual>\n      <collision>\n        <geometry>\n          <box size="0.08 0.15 0.05"/>\n        </geometry>\n      </collision>\n      <xacro:box_inertia mass="0.5" x="0.08" y="0.15" z="0.05"/>\n    </link>\n\n    <joint name="${side}_wrist_joint" type="fixed">\n      <parent link="${side}_forearm"/>\n      <child link="${side}_hand"/>\n      <origin xyz="0 0 ${-forearm_length}" rpy="0 0 0"/>\n    </joint>\n\n  </xacro:macro>\n\n  \x3c!-- ========== INERTIA MACROS ========== --\x3e\n  <xacro:macro name="cylinder_inertia" params="mass radius length">\n    <inertial>\n      <mass value="${mass}"/>\n      <origin xyz="0 0 ${-length/2}"/>\n      <inertia\n        ixx="${mass * (3 * radius * radius + length * length) / 12}"\n        ixy="0" ixz="0"\n        iyy="${mass * (3 * radius * radius + length * length) / 12}"\n        iyz="0"\n        izz="${mass * radius * radius / 2}"/>\n    </inertial>\n  </xacro:macro>\n\n  <xacro:macro name="box_inertia" params="mass x y z">\n    <inertial>\n      <mass value="${mass}"/>\n      <inertia\n        ixx="${mass * (y*y + z*z) / 12}"\n        ixy="0" ixz="0"\n        iyy="${mass * (x*x + z*z) / 12}"\n        iyz="0"\n        izz="${mass * (x*x + y*y) / 12}"/>\n    </inertial>\n  </xacro:macro>\n\n  \x3c!-- ========== ROBOT DEFINITION ========== --\x3e\n  <link name="base_link"/>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="white">\n        <color rgba="0.9 0.9 0.9 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <xacro:box_inertia mass="${torso_mass}" x="0.3" y="0.2" z="0.5"/>\n  </link>\n\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.96 0.8 0.69 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="${head_mass}"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Instantiate arms using macro --\x3e\n  <xacro:humanoid_arm side="left" reflect="1"/>\n  <xacro:humanoid_arm side="right" reflect="-1"/>\n\n</robot>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Xacro Benefits"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Properties"}),": Constants like ",(0,s.jsx)(e.code,{children:"upper_arm_length"})," defined once"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Macros"}),": ",(0,s.jsx)(e.code,{children:"humanoid_arm"})," macro creates both arms with one definition"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Math"}),": Expressions like ",(0,s.jsx)(e.code,{children:"${-upper_arm_length/2}"})," for computed values"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Parameterization"}),": ",(0,s.jsx)(e.code,{children:"reflect"})," parameter mirrors left/right arms"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"converting-xacro-to-urdf",children:"Converting Xacro to URDF"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# File: Terminal commands\n\n# Convert xacro to URDF\nros2 run xacro xacro \\\n  ~/ros2_ws/src/humanoid_description/urdf/humanoid_upper_body.urdf.xacro \\\n  > ~/ros2_ws/src/humanoid_description/urdf/humanoid_upper_body.urdf\n\n# Check the generated URDF\ncheck_urdf ~/ros2_ws/src/humanoid_description/urdf/humanoid_upper_body.urdf\n\n# Expected output:\n# robot name is: humanoid_upper_body\n# ---------- Successfully Parsed XML ---------------\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"44-visualizing-in-rviz",children:"4.4 Visualizing in RViz"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"RViz"})," is ROS 2's primary 3D visualization tool. Let's view our humanoid robot."]}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-launch-file-for-visualization",children:"Step 1: Create Launch File for Visualization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# File: ~/ros2_ws/src/humanoid_description/launch/view_robot.launch.py\n\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nimport xacro\n\ndef generate_launch_description():\n    # Get package directory\n    pkg_dir = get_package_share_directory('humanoid_description')\n\n    # Path to xacro file\n    xacro_file = os.path.join(pkg_dir, 'urdf', 'humanoid_upper_body.urdf.xacro')\n\n    # Process xacro to URDF\n    robot_description = xacro.process_file(xacro_file).toxml()\n\n    # Robot State Publisher (publishes /robot_description and TF tree)\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': robot_description}]\n    )\n\n    # Joint State Publisher GUI (move joints interactively)\n    joint_state_publisher_gui = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui',\n        name='joint_state_publisher_gui',\n        output='screen'\n    )\n\n    # RViz with custom config\n    rviz_config = os.path.join(pkg_dir, 'config', 'view_robot.rviz')\n    rviz = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen',\n        arguments=['-d', rviz_config]\n    )\n\n    return LaunchDescription([\n        robot_state_publisher,\n        joint_state_publisher_gui,\n        rviz,\n    ])\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-create-rviz-config-file",children:"Step 2: Create RViz Config File"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# File: ~/ros2_ws/src/humanoid_description/config/view_robot.rviz\n\nPanels:\n  - Class: rviz_common/Displays\n    Name: Displays\n  - Class: rviz_common/Views\n    Name: Views\n\nVisualization Manager:\n  Displays:\n    - Class: rviz_default_plugins/Grid\n      Name: Grid\n      Reference Frame: base_link\n\n    - Class: rviz_default_plugins/RobotModel\n      Name: RobotModel\n      Description Topic: /robot_description\n      Visual Enabled: true\n      Collision Enabled: false\n\n    - Class: rviz_default_plugins/TF\n      Name: TF\n      Show Axes: true\n      Show Names: true\n\n  Global Options:\n    Fixed Frame: base_link\n\n  Views:\n    Current:\n      Class: rviz_default_plugins/Orbit\n      Distance: 2.0\n      Focal Point:\n        X: 0.0\n        Y: 0.0\n        Z: 0.5\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-launch-rviz",children:"Step 3: Launch RViz"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# File: Terminal commands\n\ncd ~/ros2_ws\ncolcon build --packages-select humanoid_description\nsource install/setup.bash\n\n# Launch RViz with robot model\nros2 launch humanoid_description view_robot.launch.py\n\n# Expected: RViz opens showing humanoid robot\n# Use Joint State Publisher GUI to move joints\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key ROS 2 Nodes"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"robot_state_publisher"}),": Reads URDF, publishes TF transforms between links"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"joint_state_publisher_gui"}),": GUI sliders to manually set joint positions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"rviz2"}),": Visualization tool"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"45-gazebo-physics-simulation",children:"4.5 Gazebo Physics Simulation"}),"\n",(0,s.jsxs)(e.p,{children:["To simulate the robot with physics, we need ",(0,s.jsx)(e.strong,{children:"Gazebo URDF extensions"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"adding-gazebo-properties",children:"Adding Gazebo Properties"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: ~/ros2_ws/src/humanoid_description/urdf/humanoid_gazebo.urdf.xacro --\x3e\n\n<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_gazebo">\n\n  \x3c!-- Include base robot model --\x3e\n  <xacro:include filename="$(find humanoid_description)/urdf/humanoid_upper_body.urdf.xacro"/>\n\n  \x3c!-- ========== GAZEBO PROPERTIES ========== --\x3e\n  \x3c!-- Gazebo material colors --\x3e\n  <gazebo reference="torso">\n    <material>Gazebo/White</material>\n    <mu1>0.9</mu1>  \x3c!-- Friction coefficient --\x3e\n    <mu2>0.9</mu2>\n  </gazebo>\n\n  <gazebo reference="head">\n    <material>Gazebo/Skin</material>\n  </gazebo>\n\n  <gazebo reference="left_upper_arm">\n    <material>Gazebo/Skin</material>\n  </gazebo>\n\n  <gazebo reference="right_upper_arm">\n    <material>Gazebo/Skin</material>\n  </gazebo>\n\n  \x3c!-- ========== GAZEBO PLUGINS ========== --\x3e\n  \x3c!-- ROS 2 Control plugin for joint control --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n      <parameters>$(find humanoid_description)/config/controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Camera sensor on head --\x3e\n  <gazebo reference="head">\n    <sensor type="camera" name="head_camera">\n      <update_rate>30.0</update_rate>\n      <camera name="head">\n        <horizontal_fov>1.3962634</horizontal_fov>  \x3c!-- 80 degrees --\x3e\n        <image>\n          <width>640</width>\n          <height>480</height>\n          <format>R8G8B8</format>\n        </image>\n        <clip>\n          <near>0.1</near>\n          <far>100</far>\n        </clip>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <ros>\n          <namespace>/humanoid</namespace>\n          <remapping>image_raw:=camera/image_raw</remapping>\n          <remapping>camera_info:=camera/camera_info</remapping>\n        </ros>\n        <camera_name>head_camera</camera_name>\n        <frame_name>head</frame_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- IMU sensor on torso --\x3e\n  <gazebo reference="torso">\n    <sensor type="imu" name="torso_imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">\n        <ros>\n          <namespace>/humanoid</namespace>\n          <remapping>~/out:=imu/data</remapping>\n        </ros>\n        <frame_name>torso</frame_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n</robot>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Elements"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:'<gazebo reference="link_name">'}),": Properties for a specific link"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<material>"}),": Visual appearance in Gazebo (different from URDF materials)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<mu1>"}),", ",(0,s.jsx)(e.code,{children:"<mu2>"}),": Friction coefficients for contact dynamics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<sensor>"}),": Cameras, IMUs, LiDAR, etc."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<plugin>"}),": ROS 2 bridges for publishing sensor data and controlling joints"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"launch-gazebo-with-robot",children:"Launch Gazebo with Robot"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# File: ~/ros2_ws/src/humanoid_description/launch/gazebo_robot.launch.py\n\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nimport xacro\n\ndef generate_launch_description():\n    pkg_dir = get_package_share_directory('humanoid_description')\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n\n    # Process xacro\n    xacro_file = os.path.join(pkg_dir, 'urdf', 'humanoid_gazebo.urdf.xacro')\n    robot_description = xacro.process_file(xacro_file).toxml()\n\n    # Robot State Publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': robot_description, 'use_sim_time': True}]\n    )\n\n    # Gazebo launch file\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py')\n        ]),\n        launch_arguments={'verbose': 'true'}.items()\n    )\n\n    # Spawn robot in Gazebo\n    spawn_robot = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-entity', 'humanoid',\n            '-topic', '/robot_description',\n            '-x', '0', '-y', '0', '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        robot_state_publisher,\n        spawn_robot,\n    ])\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# File: Terminal commands\n\nros2 launch humanoid_description gazebo_robot.launch.py\n\n# Expected: Gazebo opens with humanoid robot standing at z=1.0m\n# Robot will fall due to gravity (no control yet)\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"46-collision-vs-visual-meshes",children:"4.6 Collision vs Visual Meshes"}),"\n",(0,s.jsxs)(e.p,{children:["For performance, use ",(0,s.jsx)(e.strong,{children:"simplified collision meshes"})," and ",(0,s.jsx)(e.strong,{children:"detailed visual meshes"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"example-hand-with-separate-meshes",children:"Example: Hand with Separate Meshes"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: Hand with separate collision and visual meshes --\x3e\n\n<link name="left_hand">\n  \x3c!-- Visual: High-detail mesh --\x3e\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <mesh filename="package://humanoid_description/meshes/hand_detailed.stl" scale="0.001 0.001 0.001"/>\n    </geometry>\n    <material name="skin">\n      <color rgba="0.96 0.8 0.69 1"/>\n    </material>\n  </visual>\n\n  \x3c!-- Collision: Simplified box (faster collision detection) --\x3e\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.08 0.15 0.05"/>\n    </geometry>\n  </collision>\n\n  <inertial>\n    <mass value="0.5"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n  </inertial>\n</link>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Performance Trade-offs"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual mesh"}),": Can have 100,000+ polygons for photorealism (only affects rendering)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision mesh"}),": Should have ",(0,s.jsx)(e.code,{children:"<1,000"})," polygons (affects physics computation every timestep)"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Best Practice"}),": Use primitive shapes (box, cylinder, sphere) for collision geometry whenever possible."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"47-urdf-best-practices-for-humanoids",children:"4.7 URDF Best Practices for Humanoids"}),"\n",(0,s.jsx)(e.h3,{id:"1-coordinate-frame-conventions",children:"1. Coordinate Frame Conventions"}),"\n",(0,s.jsxs)(e.p,{children:["Follow ",(0,s.jsx)(e.strong,{children:"REP-103"})," (ROS Enhancement Proposal 103):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"X-axis"}),": Forward"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Y-axis"}),": Left"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Z-axis"}),": Up"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Good: Z-axis points up --\x3e\n<joint name="base_to_torso" type="fixed">\n  <origin xyz="0 0 0.5" rpy="0 0 0"/>\n</joint>\n\n\x3c!-- Bad: Don\'t use Y-up or other conventions --\x3e\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-joint-limits",children:"2. Joint Limits"}),"\n",(0,s.jsx)(e.p,{children:"Use realistic joint limits based on human anatomy:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Elbow: 0\xb0 to 150\xb0 (humans can\'t bend backwards) --\x3e\n<limit lower="0" upper="2.617" effort="80" velocity="2.0"/>\n\n\x3c!-- Shoulder: -180\xb0 to 180\xb0 (full rotation) --\x3e\n<limit lower="-3.14" upper="3.14" effort="100" velocity="2.0"/>\n\n\x3c!-- Neck yaw: -90\xb0 to 90\xb0 (left-right rotation) --\x3e\n<limit lower="-1.57" upper="1.57" effort="50" velocity="2.0"/>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"3-mass-and-inertia",children:"3. Mass and Inertia"}),"\n",(0,s.jsx)(e.p,{children:"Accurate inertial properties are critical for stable simulation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Use realistic masses (average adult human: 70 kg total) --\x3e\n<inertial>\n  <mass value="15.0"/>  \x3c!-- Torso: ~20% of body mass --\x3e\n  <origin xyz="0 0 0.25"/>  \x3c!-- Center of mass --\x3e\n  <inertia ixx="0.5" ixy="0" ixz="0" iyy="0.5" iyz="0" izz="0.2"/>\n</inertial>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Tools for computing inertia"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"MeshLab: Calculate inertia from 3D meshes"}),"\n",(0,s.jsx)(e.li,{children:"SolidWorks/Fusion 360: Export inertia tensors"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"inertial_calculator.py"})," (custom Python script)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"4-modular-design-with-xacro",children:"4. Modular Design with Xacro"}),"\n",(0,s.jsx)(e.p,{children:"Organize complex robots into modular xacro files:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"urdf/\n\u251c\u2500\u2500 humanoid.urdf.xacro          # Main robot assembly\n\u251c\u2500\u2500 torso.urdf.xacro             # Torso and spine\n\u251c\u2500\u2500 head.urdf.xacro              # Head with cameras\n\u251c\u2500\u2500 arm.urdf.xacro               # Arm macro (reused for left/right)\n\u251c\u2500\u2500 leg.urdf.xacro               # Leg macro (reused for left/right)\n\u251c\u2500\u2500 hand.urdf.xacro              # Hand with fingers\n\u251c\u2500\u2500 sensors.gazebo.xacro         # Gazebo sensor plugins\n\u2514\u2500\u2500 materials.xacro              # Color definitions\n"})}),"\n",(0,s.jsx)(e.h3,{id:"5-version-control-urdf",children:"5. Version Control URDF"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add version and changelog comments --\x3e\n<?xml version="1.0"?>\n\x3c!--\n  Humanoid Robot URDF\n  Version: 2.1.0\n  Last Updated: 2024-03-15\n  Changes:\n    - Added camera sensor to head\n    - Increased elbow joint limits to 150\xb0\n    - Fixed inertia calculation for forearms\n--\x3e\n<robot name="humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  ...\n</robot>\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"end-of-chapter-exercises",children:"End-of-Chapter Exercises"}),"\n",(0,s.jsx)(e.p,{children:"Apply your URDF knowledge with these progressive challenges."}),"\n",(0,s.jsx)(e.h3,{id:"exercise-1-simple-mobile-robot-easy",children:"Exercise 1: Simple Mobile Robot (Easy)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Create a URDF for a differential drive mobile robot with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Rectangular base (0.4m x 0.3m x 0.1m)"}),"\n",(0,s.jsx)(e.li,{children:"Two wheels (0.1m radius, 0.05m width)"}),"\n",(0,s.jsx)(e.li,{children:"One caster wheel (sphere, 0.05m radius)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["URDF is valid (",(0,s.jsx)(e.code,{children:"check_urdf"})," passes)"]}),"\n",(0,s.jsx)(e.li,{children:"Robot displays correctly in RViz"}),"\n",(0,s.jsx)(e.li,{children:"Wheels are positioned symmetrically"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hint"}),": Use ",(0,s.jsx)(e.code,{children:"continuous"})," joints for wheels (unlimited rotation)"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"exercise-2-xacro-parameterization-easy-medium",children:"Exercise 2: Xacro Parameterization (Easy-Medium)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Convert the mobile robot from Exercise 1 to Xacro with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Properties for all dimensions (wheel_radius, base_length, etc.)"}),"\n",(0,s.jsx)(e.li,{children:"Macro for creating wheels (reuse for left/right wheels)"}),"\n",(0,s.jsx)(e.li,{children:"Ability to change robot size by modifying properties"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Xacro compiles to valid URDF"}),"\n",(0,s.jsxs)(e.li,{children:["Changing ",(0,s.jsx)(e.code,{children:"wheel_radius"})," property correctly scales wheels"]}),"\n",(0,s.jsx)(e.li,{children:"Macro creates both wheels with one definition"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"exercise-3-add-sensors-to-humanoid-medium",children:"Exercise 3: Add Sensors to Humanoid (Medium)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Extend the humanoid upper body URDF with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Camera on the head (forward-facing)"}),"\n",(0,s.jsx)(e.li,{children:"IMU on the torso"}),"\n",(0,s.jsx)(e.li,{children:"Force/torque sensors on both hands"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Sensors are defined with ",(0,s.jsx)(e.code,{children:"<gazebo>"})," tags"]}),"\n",(0,s.jsxs)(e.li,{children:["Camera publishes to ",(0,s.jsx)(e.code,{children:"/humanoid/camera/image_raw"})]}),"\n",(0,s.jsxs)(e.li,{children:["IMU publishes to ",(0,s.jsx)(e.code,{children:"/humanoid/imu/data"})]}),"\n",(0,s.jsx)(e.li,{children:"Sensors work in Gazebo simulation"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hint"}),": Use Gazebo sensor plugins (",(0,s.jsx)(e.code,{children:"libgazebo_ros_camera.so"}),", ",(0,s.jsx)(e.code,{children:"libgazebo_ros_imu_sensor.so"}),")"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"exercise-4-humanoid-legs-medium-hard",children:"Exercise 4: Humanoid Legs (Medium-Hard)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Create a xacro macro for a humanoid leg with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Hip joint (3-DOF: roll, pitch, yaw)"}),"\n",(0,s.jsx)(e.li,{children:"Knee joint (1-DOF: pitch)"}),"\n",(0,s.jsx)(e.li,{children:"Ankle joint (2-DOF: pitch, roll)"}),"\n",(0,s.jsx)(e.li,{children:"Realistic link dimensions and masses"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Macro creates both legs (left/right mirroring)"}),"\n",(0,s.jsx)(e.li,{children:"Joint limits match human anatomy"}),"\n",(0,s.jsx)(e.li,{children:"Total leg mass is ~15% of body weight per leg"}),"\n",(0,s.jsx)(e.li,{children:"Visualizes correctly in RViz"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hint"}),": Chain multiple joints for multi-DOF hip"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"exercise-5-collision-geometry-optimization-medium-hard",children:"Exercise 5: Collision Geometry Optimization (Medium-Hard)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Create a humanoid hand with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual"}),": Detailed mesh (",(0,s.jsx)(e.code,{children:".stl"})," file with fingers)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision"}),": Simplified bounding box"]}),"\n",(0,s.jsx)(e.li,{children:"Compare Gazebo performance (FPS) with detailed vs simplified collision"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Visual mesh displays in Gazebo"}),"\n",(0,s.jsx)(e.li,{children:"Collision uses simplified geometry"}),"\n",(0,s.jsx)(e.li,{children:"Document FPS improvement (should be >2x faster)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hint"}),": Use ",(0,s.jsx)(e.code,{children:"<mesh>"})," for visual, ",(0,s.jsx)(e.code,{children:"<box>"})," for collision"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"exercise-6-complete-humanoid-robot-hard",children:"Exercise 6: Complete Humanoid Robot (Hard)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task"}),": Build a full humanoid robot URDF with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Torso, head, two arms, two legs"}),"\n",(0,s.jsx)(e.li,{children:"At least 20 degrees of freedom (joints)"}),"\n",(0,s.jsx)(e.li,{children:"Sensors: 2 cameras (eyes), 1 IMU, depth camera (chest)"}),"\n",(0,s.jsx)(e.li,{children:"Modular xacro structure (separate files for arms, legs, sensors)"}),"\n",(0,s.jsx)(e.li,{children:"Gazebo integration with physics and sensors"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"URDF compiles and validates"}),"\n",(0,s.jsx)(e.li,{children:"Robot is stable when spawned in Gazebo (doesn't collapse)"}),"\n",(0,s.jsx)(e.li,{children:"All sensors publish data"}),"\n",(0,s.jsx)(e.li,{children:"Joint state publisher GUI can move all joints"}),"\n",(0,s.jsx)(e.li,{children:"RViz shows complete robot model"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Bonus"}),": Add hands with articulated fingers (3 DOF per finger)"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"capstone-integration-module-1-final-project",children:"Capstone Integration: Module 1 Final Project"}),"\n",(0,s.jsxs)(e.p,{children:["The Module 1 capstone requires a ",(0,s.jsx)(e.strong,{children:"complete humanoid head tracking system"})," with URDF integration:"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"URDF Requirements"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Humanoid upper body with head, torso, arms"}),"\n",(0,s.jsx)(e.li,{children:"Head has pan/tilt joints (2-DOF neck)"}),"\n",(0,s.jsx)(e.li,{children:"Camera sensor on head (publishes images)"}),"\n",(0,s.jsx)(e.li,{children:"Arms have shoulder (3-DOF), elbow (1-DOF), wrist (2-DOF)"}),"\n",(0,s.jsx)(e.li,{children:"Gazebo physics simulation"}),"\n",(0,s.jsx)(e.li,{children:"RViz visualization with joint control"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Integration with Previous Chapters"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Chapter 2"}),": Nodes control head joints based on face detection"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Chapter 3"}),": Launch file starts Gazebo, controllers, and perception"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Chapter 4"}),": URDF defines robot structure and sensors"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"You now have all the tools to describe any humanoid robot in URDF!"}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"In this chapter, you learned:"}),"\n",(0,s.jsxs)(e.p,{children:["\u2705 ",(0,s.jsx)(e.strong,{children:"URDF fundamentals"}),": Links, joints, visual/collision/inertial properties\n\u2705 ",(0,s.jsx)(e.strong,{children:"Humanoid modeling"}),": Creating torso, head, arms with realistic kinematics\n\u2705 ",(0,s.jsx)(e.strong,{children:"Xacro macros"}),": Eliminating duplication with properties and macros\n\u2705 ",(0,s.jsx)(e.strong,{children:"RViz visualization"}),": Viewing robots with robot_state_publisher and joint_state_publisher_gui\n\u2705 ",(0,s.jsx)(e.strong,{children:"Gazebo integration"}),": Physics simulation with sensors and controller plugins\n\u2705 ",(0,s.jsx)(e.strong,{children:"Performance optimization"}),": Separate collision/visual meshes"]}),"\n",(0,s.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF is the foundation"})," of robot description in ROS 2"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Xacro eliminates duplication"})," - always use macros for symmetric parts (arms, legs)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Accurate inertial properties"})," are critical for stable simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo plugins bridge simulation to ROS 2"})," (sensors, controllers)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visualize early and often"})," - catch kinematic errors in RViz before Gazebo"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"whats-next",children:"What's Next?"}),"\n",(0,s.jsxs)(e.p,{children:["You've completed ",(0,s.jsx)(e.strong,{children:"Module 1: The Robotic Nervous System (ROS 2)"}),"! \ud83c\udf89"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Next Steps"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Complete the ",(0,s.jsx)(e.strong,{children:"Module 1 Capstone Project"})," (head tracking system)"]}),"\n",(0,s.jsxs)(e.li,{children:["Review ",(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/ai_native-textbook/docs/module-1/week-3",children:"Weekly Practice Guides"})})," for structured exercises"]}),"\n",(0,s.jsxs)(e.li,{children:["Move to ",(0,s.jsx)(e.strong,{children:"Module 2: Digital Twin Simulation"})," for advanced Gazebo and Unity"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Need Help?"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html",children:"URDF Tutorials"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://wiki.ros.org/xacro",children:"Xacro Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"Gazebo ROS 2 Integration"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://www.ros.org/reps/rep-0103.html",children:"REP-103: Standard Units of Measure and Coordinate Conventions"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);