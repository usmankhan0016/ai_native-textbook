"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[5233],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},l=s.createContext(r);function o(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},9460:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-2/chapter-2-gazebo-physics-simulation","title":"Chapter 2: Physics Simulation in Gazebo","description":"Estimated time Intermediate | Week: 6, Days 2-5","source":"@site/docs/module-2/chapter-2-gazebo-physics-simulation.md","sourceDirName":"module-2","slug":"/module-2/chapter-2-gazebo-physics-simulation","permalink":"/ai_native-textbook/docs/module-2/chapter-2-gazebo-physics-simulation","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"gazebo","permalink":"/ai_native-textbook/docs/tags/gazebo"},{"inline":true,"label":"physics","permalink":"/ai_native-textbook/docs/tags/physics"},{"inline":true,"label":"simulation","permalink":"/ai_native-textbook/docs/tags/simulation"},{"inline":true,"label":"hands-on","permalink":"/ai_native-textbook/docs/tags/hands-on"},{"inline":true,"label":"week-6","permalink":"/ai_native-textbook/docs/tags/week-6"}],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Ch.2: Gazebo Physics","title":"Chapter 2: Physics Simulation in Gazebo","tags":["gazebo","physics","simulation","hands-on","week-6"],"difficulty":"Intermediate","module":2,"week":6,"prerequisites":["Chapter 1","Ubuntu 22.04","ROS 2 Humble"],"estimated_time":"4-5 hours","topics":["gazebo","sdf-urdf","physics-engines","ros2-integration","sensors"]},"sidebar":"tutorialSidebar","previous":{"title":"Ch.1: Digital Twin Introduction","permalink":"/ai_native-textbook/docs/module-2/chapter-1-digital-twin-introduction"},"next":{"title":"Ch.3: Sensor Simulation","permalink":"/ai_native-textbook/docs/module-2/chapter-3-sensor-simulation"}}');var r=i(4848),l=i(8453);const o={sidebar_position:2,sidebar_label:"Ch.2: Gazebo Physics",title:"Chapter 2: Physics Simulation in Gazebo",tags:["gazebo","physics","simulation","hands-on","week-6"],difficulty:"Intermediate",module:2,week:6,prerequisites:["Chapter 1","Ubuntu 22.04","ROS 2 Humble"],estimated_time:"4-5 hours",topics:["gazebo","sdf-urdf","physics-engines","ros2-integration","sensors"]},a="Chapter 2: Physics Simulation in Gazebo",t={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Gazebo Architecture Overview",id:"gazebo-architecture-overview",level:2},{value:"Components",id:"components",level:3},{value:"World File Structure",id:"world-file-structure",level:3},{value:"URDF vs. SDF: When to Use Each",id:"urdf-vs-sdf-when-to-use-each",level:2},{value:"Comparison Table",id:"comparison-table",level:3},{value:"Example: URDF (Robot Structure)",id:"example-urdf-robot-structure",level:3},{value:"Example: SDF (World with Physics)",id:"example-sdf-world-with-physics",level:3},{value:"Physics Engines Comparison",id:"physics-engines-comparison",level:2},{value:"Comparison Table",id:"comparison-table-1",level:3},{value:"ODE (Default)",id:"ode-default",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART",id:"dart",level:3},{value:"Creating Your First Gazebo World",id:"creating-your-first-gazebo-world",level:2},{value:"Step 1: Create World File",id:"step-1-create-world-file",level:3},{value:"Step 2: Launch Gazebo with Your World",id:"step-2-launch-gazebo-with-your-world",level:3},{value:"Loading Humanoid Robots",id:"loading-humanoid-robots",level:2},{value:"Method 1: Include in SDF",id:"method-1-include-in-sdf",level:3},{value:"Method 2: Spawn via ROS 2 Service",id:"method-2-spawn-via-ros-2-service",level:3},{value:"Configuring Physics Parameters",id:"configuring-physics-parameters",level:2},{value:"Gravity",id:"gravity",level:3},{value:"Friction",id:"friction",level:3},{value:"Damping (Friction-like Resistance)",id:"damping-friction-like-resistance",level:3},{value:"Collision Margin (Critical for Stability)",id:"collision-margin-critical-for-stability",level:3},{value:"Handling Collisions",id:"handling-collisions",level:2},{value:"Collision Detection",id:"collision-detection",level:3},{value:"Surface Properties",id:"surface-properties",level:3},{value:"Adding Sensors to Gazebo",id:"adding-sensors-to-gazebo",level:2},{value:"Camera Plugin (RGB Image)",id:"camera-plugin-rgb-image",level:3},{value:"IMU Plugin (Acceleration + Rotation)",id:"imu-plugin-acceleration--rotation",level:3},{value:"Debugging Physics Issues",id:"debugging-physics-issues",level:2},{value:"Visualization Tools in Gazebo",id:"visualization-tools-in-gazebo",level:3},{value:"ROS 2 Inspection Commands",id:"ros-2-inspection-commands",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Joint State Publisher",id:"joint-state-publisher",level:3},{value:"Sending Commands via ROS 2",id:"sending-commands-via-ros-2",level:3},{value:"Hands-On Labs",id:"hands-on-labs",level:2},{value:"Lab 1: Install Gazebo and Verify Installation",id:"lab-1-install-gazebo-and-verify-installation",level:3},{value:"Lab 2: Create Custom World with Ground and Objects",id:"lab-2-create-custom-world-with-ground-and-objects",level:3},{value:"Lab 3: Configure and Visualize Sensors",id:"lab-3-configure-and-visualize-sensors",level:3},{value:"End-of-Chapter Exercises",id:"end-of-chapter-exercises",level:2},{value:"Exercise 1: Create a Multi-Object World",id:"exercise-1-create-a-multi-object-world",level:3},{value:"Exercise 2: Physics Parameter Tuning",id:"exercise-2-physics-parameter-tuning",level:3},{value:"Exercise 3: Load and Move Humanoid",id:"exercise-3-load-and-move-humanoid",level:3},{value:"Exercise 4: Compare Physics Engines",id:"exercise-4-compare-physics-engines",level:3},{value:"Summary",id:"summary",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-2-physics-simulation-in-gazebo",children:"Chapter 2: Physics Simulation in Gazebo"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Estimated time"}),": 4-5 hours | ",(0,r.jsx)(n.strong,{children:"Difficulty"}),": Intermediate | ",(0,r.jsx)(n.strong,{children:"Week"}),": 6, Days 2-5"]}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Install and verify"})," Gazebo on Ubuntu 22.04 with all dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Understand Gazebo architecture"})," including world files, plugins, and physics engines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distinguish between URDF and SDF"})," formats and when to use each"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configure physics engines"})," (ODE, Bullet, DART) and understand their trade-offs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create custom Gazebo worlds"})," with ground planes, objects, and physics parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load and spawn humanoid robots"})," from URDF files into your simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug physics issues"})," using Gazebo visualization tools and ROS 2 inspection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configure sensors"})," (cameras, IMU, LiDAR) with SDF plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interact with simulations"})," using ROS 2 commands and custom control nodes"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),": XML-based file format for describing Gazebo worlds, robots, and physics parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF (Unified Robot Description Format)"}),": XML format for robot structure (links, joints, sensors) created in Module 1"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics engine"}),": Software (ODE, Bullet, DART, PhysX) that computes collisions and rigid-body dynamics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin"}),": Gazebo extension that adds functionality (sensors, actuators, controllers) to simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"World file"}),": SDF description of the entire simulation environment (gravity, ground, objects, robots)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"gazebo-architecture-overview",children:"Gazebo Architecture Overview"}),"\n",(0,r.jsx)(n.h3,{id:"components",children:"Components"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo consists of several key components that work together:"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    Client["Gazebo Client<br/>(GUI)"]\n    Server["Gazebo Server<br/>(Physics, Plugins)"]\n    ROS2["ROS 2 Interface<br/>(gazebo_ros plugins)"]\n    WorldFile["World File<br/>(SDF)"]\n    URDFs["Robot URDFs<br/>(URDF)"]\n\n    Client --\x3e|Visualization| Server\n    Server --\x3e|Loads| WorldFile\n    Server --\x3e|Loads| URDFs\n    Server <--\x3e|Topics/Services| ROS2\n    ROS2 <--\x3e|Commands| Server\n\n    style Server fill:#e1f5ff\n    style ROS2 fill:#fff3e0'}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Server"}),": The core simulation engine running physics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Client"}),": GUI for visualization and interaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"World File (SDF)"}),": Defines the environment (gravity, ground, objects)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robot URDFs"}),": Describe individual robots (from Module 1)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugins"}),": Extend functionality (cameras, IMU, control)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 Interface"}),": Bridges simulation to your control algorithms"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"world-file-structure",children:"World File Structure"}),"\n",(0,r.jsx)(n.p,{children:"A basic Gazebo world file (SDF format) looks like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="my_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics name="default_physics" type="ode">\n      <gravity>0 0 -9.81</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n          <precon_iters>0</precon_iters>\n          <sor>1.3</sor>\n          <use_dynamic_moi_rescaling>false</use_dynamic_moi_rescaling>\n        </solver>\n      </ode>\n    </physics>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Custom objects and robots are added here --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"urdf-vs-sdf-when-to-use-each",children:"URDF vs. SDF: When to Use Each"}),"\n",(0,r.jsx)(n.p,{children:"Both formats describe robots and objects, but they serve different purposes:"}),"\n",(0,r.jsx)(n.h3,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"URDF"}),(0,r.jsx)(n.th,{children:"SDF"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Purpose"})}),(0,r.jsx)(n.td,{children:"Describe robot structure"}),(0,r.jsx)(n.td,{children:"Describe simulation world and physics"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scope"})}),(0,r.jsx)(n.td,{children:"One robot (links, joints, sensors)"}),(0,r.jsx)(n.td,{children:"Entire scene (robots, ground, objects, physics)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Physics"})}),(0,r.jsx)(n.td,{children:"Limited (collision geometry)"}),(0,r.jsx)(n.td,{children:"Complete (gravity, engines, constraints)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Use Case"})}),(0,r.jsx)(n.td,{children:"Created once, reused everywhere"}),(0,r.jsx)(n.td,{children:"Created per simulation scenario"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Format"})}),(0,r.jsx)(n.td,{children:"XML (simpler subset)"}),(0,r.jsx)(n.td,{children:"XML (more complex)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Example"})}),(0,r.jsx)(n.td,{children:"humanoid.urdf"}),(0,r.jsx)(n.td,{children:"my_world.world (SDF)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"example-urdf-robot-structure",children:"Example: URDF (Robot Structure)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- File: humanoid.urdf (from Module 1) --\x3e\n<?xml version="1.0" ?>\n<robot name="humanoid">\n  <link name="base_link">\n    <inertial>\n      <mass value="70.0" />  \x3c!-- kg --\x3e\n      <inertia ixx="5.0" ixy="0" ixz="0" iyy="5.0" iyz="0" izz="2.0" />\n    </inertial>\n    <collision>\n      <geometry>\n        <cylinder length="0.5" radius="0.2" />\n      </geometry>\n    </collision>\n    <visual>\n      <geometry>\n        <cylinder length="0.5" radius="0.2" />\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1" />\n      </material>\n    </visual>\n  </link>\n\n  <joint name="left_hip" type="revolute">\n    <parent link="base_link" />\n    <child link="left_thigh" />\n    <axis xyz="0 1 0" />  \x3c!-- Rotate around Y-axis --\x3e\n    <limit lower="-0.785" upper="0.785" effort="300" velocity="1.0" />\n  </joint>\n  \x3c!-- More joints... --\x3e\n</robot>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-sdf-world-with-physics",children:"Example: SDF (World with Physics)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- File: humanoid_world.sdf --\x3e\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_sim">\n    \x3c!-- Define physics engine and parameters --\x3e\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>  \x3c!-- 1000 Hz --\x3e\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.81</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Ground plane model --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>  \x3c!-- Friction coefficient --\x3e\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Humanoid robot loaded from URDF --\x3e\n    <include>\n      <uri>file:///path/to/humanoid.urdf</uri>\n      <name>humanoid_robot</name>\n      <pose>0 0 1.0 0 0 0</pose>  \x3c!-- Position: x=0, y=0, z=1.0m (above ground) --\x3e\n    </include>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"physics-engines-comparison",children:"Physics Engines Comparison"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo supports multiple physics engines. Each has different characteristics:"}),"\n",(0,r.jsx)(n.h3,{id:"comparison-table-1",children:"Comparison Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Engine"}),(0,r.jsx)(n.th,{children:"Speed"}),(0,r.jsx)(n.th,{children:"Accuracy"}),(0,r.jsx)(n.th,{children:"Stability"}),(0,r.jsx)(n.th,{children:"Best For"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"})}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Good"}),(0,r.jsx)(n.td,{children:"General robotics, research"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bullet"})}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Real-time responsiveness"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"})}),(0,r.jsx)(n.td,{children:"Slow"}),(0,r.jsx)(n.td,{children:"Very High"}),(0,r.jsx)(n.td,{children:"Excellent"}),(0,r.jsx)(n.td,{children:"Humanoid dynamics, research"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"ode-default",children:"ODE (Default)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Speed"}),": Medium - handles most simulations in real-time or faster"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accuracy"}),": High - uses iterative solver, good for long-horizon sims"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability"}),": Generally stable with proper parameter tuning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use"}),": Default for Gazebo, good general-purpose choice"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>50</iters>\n    </solver>\n  </ode>\n</physics>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Speed"}),": Fastest - optimized for real-time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accuracy"}),": Medium - faster but less precise"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability"}),": Can be jumpy without tuning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use"}),": When speed is critical, initial prototyping"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics type="bullet">\n  <max_step_size>0.001</max_step_size>\n  <bullet>\n    <solver>\n      <type>sequential_impulse</type>\n      <iters>50</iters>\n    </solver>\n  </bullet>\n</physics>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dart",children:"DART"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Speed"}),": Slowest - intensive computation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accuracy"}),": Very high - accurate humanoid dynamics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability"}),": Excellent stability, even with extreme parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use"}),": Humanoid research, validation before hardware"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics type="dart">\n  <max_step_size>0.001</max_step_size>\n  <dart>\n    <solver>\n      <solver_type>dantzig</solver_type>\n    </solver>\n  </dart>\n</physics>\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"creating-your-first-gazebo-world",children:"Creating Your First Gazebo World"}),"\n",(0,r.jsx)(n.p,{children:"Let's walk through creating a simple simulation world step-by-step."}),"\n",(0,r.jsx)(n.h3,{id:"step-1-create-world-file",children:"Step 1: Create World File"}),"\n",(0,r.jsxs)(n.p,{children:["Create a file named ",(0,r.jsx)(n.code,{children:"my_world.sdf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="simple_world">\n    \x3c!-- Physics --\x3e\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.81</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n          <sor>1.3</sor>\n        </solver>\n      </ode>\n    </physics>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n      <pose>0 0 10 0 0 0</pose>\n    </include>\n\n    \x3c!-- A simple box obstacle --\x3e\n    <model name="box_obstacle">\n      <static>false</static>\n      <pose>2.0 0 0.5 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>5.0</mass>\n          <inertia>\n            <ixx>0.04</ixx>\n            <iyy>0.04</iyy>\n            <izz>0.04</izz>\n          </inertia>\n        </inertial>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1.0 1.0 1.0</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.7</mu>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1.0 1.0 1.0</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>  \x3c!-- Red --\x3e\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-launch-gazebo-with-your-world",children:"Step 2: Launch Gazebo with Your World"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo my_world.sdf\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should see the ground plane, a red box obstacle, and sun lighting. Congratulations! You've created your first Gazebo world."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"loading-humanoid-robots",children:"Loading Humanoid Robots"}),"\n",(0,r.jsx)(n.p,{children:"To add a humanoid robot (from Module 1) to your world:"}),"\n",(0,r.jsx)(n.h3,{id:"method-1-include-in-sdf",children:"Method 1: Include in SDF"}),"\n",(0,r.jsx)(n.p,{children:"Add this to your world file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- In my_world.sdf, inside the <world> tag --\x3e\n<include>\n  <uri>file:///path/to/humanoid.urdf</uri>\n  <name>humanoid_robot</name>\n  <pose>0 0 1.5 0 0 0</pose>  \x3c!-- x=0, y=0, z=1.5m (start above ground) --\x3e\n</include>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-2-spawn-via-ros-2-service",children:"Method 2: Spawn via ROS 2 Service"}),"\n",(0,r.jsx)(n.p,{children:"Use the provided Python script from Chapter 1:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run your_package spawn_object_client\n"})}),"\n",(0,r.jsx)(n.p,{children:"This will add the robot to a running Gazebo simulation."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"configuring-physics-parameters",children:"Configuring Physics Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Physics parameters control how realistically the simulation behaves. Key parameters:"}),"\n",(0,r.jsx)(n.h3,{id:"gravity",children:"Gravity"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- In physics section --\x3e\n<gravity>0 0 -9.81</gravity>  \x3c!-- m/s\xb2 (Earth gravity) --\x3e\n"})}),"\n",(0,r.jsx)(n.h3,{id:"friction",children:"Friction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- In model collision surface --\x3e\n<surface>\n  <friction>\n    <ode>\n      <mu>0.7</mu>  \x3c!-- Coefficient of friction: 0.5-2.0 --\x3e\n      <mu2>0.7</mu2>  \x3c!-- For anisotropic friction --\x3e\n      <slip1>0.0</slip1>  \x3c!-- Slip velocity --\x3e\n      <slip2>0.0</slip2>\n    </ode>\n  </friction>\n</surface>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tuning guidance"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mu = 0.5"}),": Slippery (ice, smooth plastic)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mu = 0.7"}),": Default (rubber on concrete)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mu = 1.5"}),": Very grippy (rubber on rough surface)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mu = 2.0+"}),": Extremely sticky"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"damping-friction-like-resistance",children:"Damping (Friction-like Resistance)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In link definition --\x3e\n<link name="torso">\n  <inertial>\n    <mass>30.0</mass>\n    <inertia>...</inertia>\n    \x3c!-- Linear damping: reduces linear velocity --\x3e\n    <velocity_decay>\n      <linear>0.05</linear>  \x3c!-- 0.0-1.0, higher = more damping --\x3e\n      <angular>0.01</angular>  \x3c!-- Same for rotation --\x3e\n    </velocity_decay>\n  </inertial>\n  \x3c!-- ... collision/visual ... --\x3e\n</link>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"collision-margin-critical-for-stability",children:"Collision Margin (Critical for Stability)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- In ODE solver constraints --\x3e\n<ode>\n  <constraints>\n    <contact_surface_layer>0.001</contact_surface_layer>  \x3c!-- 1mm buffer --\x3e\n    <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n  </constraints>\n</ode>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Effect"}),": Smaller margin = tighter tolerance but more unstable. Larger = looser but more stable."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"handling-collisions",children:"Handling Collisions"}),"\n",(0,r.jsx)(n.h3,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo checks for collisions between objects automatically. For a collision to be detected, both objects need:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    <cylinder length="0.5" radius="0.1" />\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"surface-properties",children:"Surface Properties"}),"\n",(0,r.jsx)(n.p,{children:"Define how objects behave when they collide:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <bounce>\n    <restitution_coefficient>0.2</restitution_coefficient>  \x3c!-- 0.0=no bounce, 1.0=bouncy --\x3e\n  </bounce>\n  <friction>\n    <ode>\n      <mu>0.7</mu>\n      <mu2>0.7</mu2>\n    </ode>\n  </friction>\n  <contact>\n    <ode>\n      <soft_cfm>0.0</soft_cfm>\n      <soft_erp>0.2</soft_erp>\n      <kp>1000000.0</kp>\n      <kd>1.0</kd>\n      <max_vel>0.01</max_vel>\n      <min_depth>0.001</min_depth>\n    </ode>\n  </contact>\n</surface>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"adding-sensors-to-gazebo",children:"Adding Sensors to Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"camera-plugin-rgb-image",children:"Camera Plugin (RGB Image)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to humanoid robot\'s head link in world file --\x3e\n<sensor name="front_camera" type="camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.01</near>\n      <far>300</far>\n    </clip>\n  </camera>\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <visualize>true</visualize>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <ros>\n      <namespace>humanoid_robot</namespace>\n      <remapping>image_raw:=camera/image_raw</remapping>\n      <remapping>camera_info:=camera/camera_info</remapping>\n    </ros>\n    <camera_name>front_camera</camera_name>\n    <frame_name>camera_frame</frame_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"imu-plugin-acceleration--rotation",children:"IMU Plugin (Acceleration + Rotation)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to humanoid robot\'s torso link --\x3e\n<sensor name="imu_sensor" type="imu">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <visualize>false</visualize>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.001</stddev>  \x3c!-- Small noise --\x3e\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.001</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.001</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\n    <ros>\n      <namespace>humanoid_robot</namespace>\n      <remapping>imu:=imu/data</remapping>\n    </ros>\n    <initial_orientation_as_reference>false</initial_orientation_as_reference>\n  </plugin>\n</sensor>\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"debugging-physics-issues",children:"Debugging Physics Issues"}),"\n",(0,r.jsx)(n.h3,{id:"visualization-tools-in-gazebo",children:"Visualization Tools in Gazebo"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Show Center of Mass"}),": Tools \u2192 View \u2192 Show Center of Mass (red sphere on each body)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Show Collisions"}),": Tools \u2192 View \u2192 Show Collisions (visualize collision geometry)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Show Joints"}),": Tools \u2192 View \u2192 Show Joints (show joint axes)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Show Transparent"}),": Tools \u2192 View \u2192 Show Transparent (see inside objects)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ros-2-inspection-commands",children:"ROS 2 Inspection Commands"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# List all robots and objects in simulation\nros2 service list | grep gazebo\n\n# Check joint states\nros2 topic echo /joint_states\n\n# Check sensor topics\nros2 topic list | grep humanoid_robot\n\n# Get info about a specific topic\nros2 topic info /joint_states\n"})}),"\n",(0,r.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Robot sinks through ground or falls unexpectedly"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Incorrect mass, inertia, or collision geometry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Check URDF inertia tensor, ensure collision meshes match visual meshes"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Jittering/vibration when at rest"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Friction too low, contact parameters too stiff"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Increase friction (mu to 1.0+), increase contact_surface_layer"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Slow simulation (running slower than real-time)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Physics engine can't keep up, too many objects/constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Reduce world complexity, use Bullet instead of DART, lower ODE iterations"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,r.jsx)(n.h3,{id:"joint-state-publisher",children:"Joint State Publisher"}),"\n",(0,r.jsx)(n.p,{children:"The humanoid's current joint angles are published automatically:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# View joint states\nros2 topic echo /joint_states\n\n# Output:\n# header:\n#   stamp: {sec: 123, nanosec: 456}\n#   frame_id: ''\n# name: [left_hip_flexion, left_hip_abduction, ...]\n# position: [0.1, 0.05, ...]  # radians\n# velocity: [0.01, 0.02, ...]  # rad/s\n# effort: [10.5, 5.2, ...]  # torques in Nm\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sending-commands-via-ros-2",children:"Sending Commands via ROS 2"}),"\n",(0,r.jsx)(n.p,{children:"Use a ROS 2 control plugin to command joint movements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# File: src/joint_commander.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass JointCommander(Node):\n    def __init__(self):\n        super().__init__('joint_commander')\n        # Publisher for joint commands\n        self.cmd_pub = self.create_publisher(JointState, '/humanoid_robot/cmd_vel', 10)\n        self.timer = self.create_timer(0.1, self.send_command)\n\n    def send_command(self):\n        # Command a simple walking motion\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = ['left_hip_flexion', 'right_hip_flexion']\n        msg.position = [0.5, -0.5]  # Opposite legs\n        msg.velocity = [0.0, 0.0]\n        msg.effort = [0.0, 0.0]\n        self.cmd_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointCommander()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-labs",children:"Hands-On Labs"}),"\n",(0,r.jsx)(n.h3,{id:"lab-1-install-gazebo-and-verify-installation",children:"Lab 1: Install Gazebo and Verify Installation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Objective"}),": Set up Gazebo on your Ubuntu 22.04 machine and verify it's working."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Update package list: ",(0,r.jsx)(n.code,{children:"sudo apt-get update"})]}),"\n",(0,r.jsxs)(n.li,{children:["Install Gazebo: ",(0,r.jsx)(n.code,{children:"sudo apt-get install gazebo"})]}),"\n",(0,r.jsxs)(n.li,{children:["Verify installation:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo --version\n# Output: Gazebo 11.x.x  (or later version)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Launch Gazebo:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo\n# Gazebo GUI should open with empty world\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verification"}),": Gazebo window opens, shows empty world with sun and ground plane."]}),"\n",(0,r.jsx)(n.h3,{id:"lab-2-create-custom-world-with-ground-and-objects",children:"Lab 2: Create Custom World with Ground and Objects"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Objective"}),": Create a Gazebo world with a ground plane, a 1m \xd7 1m \xd7 1m box, and a humanoid robot."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Create ",(0,r.jsx)(n.code,{children:"my_humanoid_world.sdf"}),' (use example from "Creating Your First Gazebo World" section)']}),"\n",(0,r.jsx)(n.li,{children:"Ensure your humanoid.urdf is accessible"}),"\n",(0,r.jsxs)(n.li,{children:["Launch:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo my_humanoid_world.sdf\n"})}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Verify: You should see ground plane, red box, and humanoid robot standing on ground"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verification Checklist"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Ground plane visible"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Red box at position (2, 0, 0.5)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Humanoid robot standing upright at origin"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 No error messages in terminal"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lab-3-configure-and-visualize-sensors",children:"Lab 3: Configure and Visualize Sensors"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Objective"}),": Add a camera and IMU to the humanoid, publish sensor data to ROS 2 topics, and visualize."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:'Modify your world file to include camera and IMU plugins (from "Adding Sensors" section)'}),"\n",(0,r.jsxs)(n.li,{children:["Launch Gazebo:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo my_humanoid_world.sdf\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["In another terminal, view camera images:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run rqt_image_view rqt_image_view\n# Select /humanoid_robot/camera/image_raw\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["In another terminal, view IMU data:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /humanoid_robot/imu/data\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verification Checklist"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Camera images display in rqt_image_view"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 IMU data prints with acceleration and angular velocity"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Physically moving humanoid (in GUI) changes sensor readings"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"end-of-chapter-exercises",children:"End-of-Chapter Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-1-create-a-multi-object-world",children:"Exercise 1: Create a Multi-Object World"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Task"}),": Create a Gazebo world file with:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ground plane"}),"\n",(0,r.jsx)(n.li,{children:"A 2m \xd7 2m \xd7 0.1m flat platform at (0, 0, 0.5)"}),"\n",(0,r.jsx)(n.li,{children:"Three objects of different masses: 1kg box, 5kg cylinder, 10kg sphere, arranged in a line"}),"\n",(0,r.jsx)(n.li,{children:"Your humanoid robot at the origin"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"World file is valid SDF (gazebo launches without errors)"}),"\n",(0,r.jsx)(n.li,{children:"All objects are visible in Gazebo GUI"}),"\n",(0,r.jsx)(n.li,{children:"Objects have realistic physics (fall due to gravity, collide with ground)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hint"}),": Use ",(0,r.jsx)(n.code,{children:"<model>"})," tags with ",(0,r.jsx)(n.code,{children:"<link>"}),", ",(0,r.jsx)(n.code,{children:"<collision>"}),", and ",(0,r.jsx)(n.code,{children:"<visual>"})," elements for each object."]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-2-physics-parameter-tuning",children:"Exercise 2: Physics Parameter Tuning"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Task"}),": Modify physics parameters to make the world more stable:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start with ODE solver with ",(0,r.jsx)(n.code,{children:"iters=50"})]}),"\n",(0,r.jsxs)(n.li,{children:["Incrementally increase to ",(0,r.jsx)(n.code,{children:"iters=100"})]}),"\n",(0,r.jsx)(n.li,{children:"Add contact_surface_layer of 0.002m"}),"\n",(0,r.jsx)(n.li,{children:"Increase friction coefficient on all objects to 1.0"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Objects no longer vibrate when resting"}),"\n",(0,r.jsx)(n.li,{children:"Humanoid is stable and doesn't sink through ground"}),"\n",(0,r.jsx)(n.li,{children:"Simulation still runs smoothly (no slowdown)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-3-load-and-move-humanoid",children:"Exercise 3: Load and Move Humanoid"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Task"}),": Load your humanoid into Gazebo and use a ROS 2 node to command joint movements."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Humanoid spawns in Gazebo at a specified pose"}),"\n",(0,r.jsxs)(n.li,{children:["ROS 2 node subscribes to ",(0,r.jsx)(n.code,{children:"/joint_states"})," and logs joint angles"]}),"\n",(0,r.jsx)(n.li,{children:"Moving the humanoid (gravity or joint commands) changes logged joint angles"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-4-compare-physics-engines",children:"Exercise 4: Compare Physics Engines"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Task"}),": Create two identical worlds, one with ODE and one with Bullet physics. Compare how a humanoid falls due to gravity."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Acceptance Criteria"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Both worlds simulate identically initially"}),"\n",(0,r.jsx)(n.li,{children:"Measure fall time (should be similar)"}),"\n",(0,r.jsx)(n.li,{children:"Document any visual differences (jitter, stability)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, you've learned:"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Gazebo architecture"}),": Server, client, world files, plugins"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"URDF vs. SDF"}),": URDF for robots, SDF for worlds and physics"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Physics engines"}),": ODE (general), Bullet (fast), DART (accurate)"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Creating worlds"}),": Gravity, ground planes, objects with physics"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Loading robots"}),": Spawning humanoids from URDF into your worlds"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Physics parameters"}),": Friction, damping, collision margins for stable simulation"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Sensor plugins"}),": Cameras and IMU for perception"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"ROS 2 integration"}),": Topics and services for control"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsxs)(n.p,{children:["Now that you can create physics simulations, Chapter 3 focuses on ",(0,r.jsx)(n.strong,{children:"Sensor Simulation"}),". You'll:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add LiDAR sensors for navigation"}),"\n",(0,r.jsx)(n.li,{children:"Configure depth cameras with realistic noise"}),"\n",(0,r.jsx)(n.li,{children:"Simulate IMU sensors for odometry"}),"\n",(0,r.jsx)(n.li,{children:"Visualize all sensor data in RViz"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Estimated time for Chapter 3"}),": 4-5 hours"]}),"\n",(0,r.jsxs)(n.p,{children:["Ready? Head to ",(0,r.jsx)(n.a,{href:"/ai_native-textbook/docs/module-2/chapter-3-sensor-simulation",children:"Chapter 3: Sensor Simulation (LiDAR, Depth Camera, IMU)"}),"!"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);